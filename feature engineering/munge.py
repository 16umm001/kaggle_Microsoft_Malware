'''
MUNGE function that returns pseudo unlabeled data
'''
import numpy as np
import random
from sklearn.neighbors import NearestNeighbors
from sklearn.preprocessing import scale
from xgboost_multi import XGBC

def munge(data, labels, p = 0.75, k = 5):
	'''
	k is the size multiplier
	p is the probability that it swaps attributes
	data is the original data 
	'''
	# pse will store the original + pseudo data
	data = data.astype(float) # convert features to float just in case.
	#pse = data.copy() 
	size = 0
	random.seed(1234)
	while size < k:
		size +=1
		tmp = data.copy()
		for index, row in enumerate(tmp): # loop through each row
			closest_nb = near_nb(index, tmp)
			for i in xrange(len(row)):
				if random.random() < p:
					row[i], closest_nb[i] = closest_nb[i], row[i]
		if size == 1:
			pse = tmp
		else:
			pse = np.concatenate((pse, tmp))
	# run xgboost on it, to get the pseudo label.
	print "start doing pseudo modelling..."
	clf = XGBC(num_round = 200, max_depth = 2, eta = 0.25, min_child_weight = 2, nthread = 2, objective = 'multi:softmax')
	clf.fit(data, labels)
	pseudo_label = clf.predict_proba(pse)
	return np.concatenate((data, pse)), np.concatenate((labels, pseudo_label))


def near_nb(vec_index, ary):
	'''
	find the nearest neighbour of vec in scaled ary
	return the row in ary
	'''
	norm_ary = scale( ary, axis=0, with_mean=True, with_std=True, copy=True )
	nbrs = NearestNeighbors(n_neighbors=2, algorithm='ball_tree').fit(norm_ary)
	indices = nbrs.kneighbors(norm_ary, return_distance = False)
	right_index = indices[vec_index][1]
	return ary[right_index]